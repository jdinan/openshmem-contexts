+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+
                 OpenSHMEM Contexts Specification v0.1
  
                               James Dinan
                               Intel Corp.
                                May, 2015
+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+

Notes to the reader:

This specification is formatted according to the guidelines of the OpenSHMEM
specification.

The specified API is intended to complement the existing thread safety API
provided by Cray SHMEM, which adds a /shmem_init_thread/ routine and thread
safety levels SHMEM_THREAD_SINGLE, SHMEM_THREAD_SERIALIZED, and
SHMEM_THREAD_MULTIPLE.  In addition, we also assume the nonblocking
communication API provided by Cray SHMEM.

------------------------------
XX.XX COMMUNICATION CONTEXTS
------------------------------

Communication contexts can be used to perform sets of independent communcation
operations, where each set is synchronized separately.  This functionality may
be useful for overlapping sets of communication operations.  It can also be
used to isolate communication operations performed by threads, eliminating
interference between threads when multithreaded processes are used.  Further,
when parallel communication resources are available, implementations may
utilize contexts to map operations performed by separate threads to separate
resource sets.

------------------------------
XX.XX.1 Constants and Types
------------------------------

We introduce the following new constants:

    SHMEM_CTX_DEFAULT - The default context.  All point-to-point communication
    operations and synchronizations that do not specify a context are performed
    on the default context.  The thread safety model of the default context is
    identical to the thread safety model with which the OpenSHMEM library was
    initialized.

    SHMEM_CTX_NULL - An invalid context handle value.

We introduce the following new handle types:

    shmem_ctx_t - An opaque handle to a SHMEM context.  It is valid to use this
    handle value in language-level assignment and comparison operations.

------------------------------
XX.XX.2 Context Creation
------------------------------

The following function is used to create communication contexts.

SYNOPSIS

    C/C++:
    int shmem_ctx_create(int num_ctx, int thread_level, shmem_ctx_t ctx[]);

    Fortran:
    WIP

DESCRIPTION

Arguments
    IN  num_ctx      Number of contexts that will be created
    IN  thread_level Thread safety model for new contexts
    OUT ctx          Array of length /num_ctx/ context handles

API Description

    /shmem_ctx_create/ creates up to contexts /num_ctx/ contexts and returns
    handles to the created contexts in the /ctx/ array.  Entries in the /ctx/
    array at indices up to the number of contexts created are set to valid
    context handles.  The remaining entries are set to SHMEM_CTX_NULL.

    The /thread_level/ argument can be used to restrict the thread safety model
    that will be used when performing operations using the given context.  This
    argument must be the same as or more restrictive than the threading model
    with which the OpenSHMEM library was initialized.  For example, in a
    multithreaded SHMEM process, a single thread may use a given context.  In
    this case, the SHMEM library does not need to synchronize accesses to
    context-specific state and the given context can be used in a
    SHMEM_THREAD_SERIALIZED model.

Return Values

    Integer - number of contexts that were created.  May be less than the
    number requested if adequate resources are not available.

Notes

    None.

Notes to OpenSHMEM Committee

    Instead of thread_level, we may want a more general ``assertions'' field
    that can convey additional information about usage model.  Since I don't
    know of such a use case right now, I chose the simpler thread_level
    argument.

------------------------------
XX.XX.3 Context Destruction
------------------------------

The following function is used to free communication contexts.

SYNOPSIS

    C/C++:
    void shmem_ctx_destroy(int num_ctx, shmem_ctx_t ctx[]);

    Fortran:
    WIP

DESCRIPTION

Arguments
    IN    num_ctx Number of contexts that will be freed
    INOUT ctx     Array of length /num_ctx/ context handles

API Description

    /shmem_ctx_destroy/ destroys contexts that were created by a call to
    /shmem_ctx_create/.  The destroyed entries in /ctx/ are reset to
    SHMEM_CTX_NULL.

Return Values

    None.

Notes

    None.

------------------------------
XX.XX.5 Context Fence
------------------------------

Assures ordering of delivery of Put, AMOs, and memory store routines to
symmetric data objects accessed using the given context.

SYNOPSIS

    C/C++:
    void shmem_ctx_fence(shmem_ctx_t ctx);

    Fortran:
    WIP

DESCRIPTION

Arguments
    IN ctx Context on which to perform the fence operation

API Description

    This routine assures ordering of delivery of Put and AMO operations
    performed on /ctx/, and memory store operations to symmetric data objects.
    All Put and AMO operations issued on /ctx/, and memory store operations to
    symmetric data objects issued to a particular remote PE prior to the call
    to /shmem_ctx_fence/ are guaranteed to be delivered before any subsequent
    Put, AMOs, and memory store routines to symmetric data objects to the same
    PE. /shmem_ctx_fence/ guarantees order of delivery, not completion.

    A /ctx/ value of SHMEM_CTX_NULL is invalid and results in undefined
    behavior.

Return Values

    None.

Notes

    Similar to /shmem_fence/, /shmem_ctx_fence/ only provides per-PE ordering
    guarantees and does not guarantee completion of delivery.  See Section
    8.7.1 for additional notes on the /shmem_fence/ routine.

Notes to OpenSHMEM Committee

    Do we want to exclude memory store operations in fence/quiet routines?  If
    we had this semantic, we might need to add a separate routine that
    synchronized just memory store operations, which might not be a bad thing
    since fence/quiet is a heavy hammer for ordering accesses to interprocess
    shared memory (e.g.  via shmem_ptr pointers).

------------------------------
XX.XX.5 Context Quiet
------------------------------

Waits for completion of all outstanding Put, AMOs and memory store routines to
symmetric data objects issued by a PE using the given context.

SYNOPSIS

    C/C++:
    void shmem_ctx_quiet(shmem_ctx_t ctx);

    Fortran:
    WIP

DESCRIPTION

Arguments
    IN ctx Context on which to perform the quiet operation

API Description

    The /shmem_ctx_quiet/ routine ensures completion of Put and AMO operations
    performed on /ctx/, and memory store operations on symmetric data objects
    issued by the calling PE. All Put and AMO operations issued on /ctx/, and
    memory store routines to symmetric data objects are guaranteed to be
    completed and visible to all PEs when /shmem_ctx_quiet/ returns.

    A /ctx/ value of SHMEM_CTX_NULL is invalid and results in undefined
    behavior.

Return Values

    None.

Notes

    See Section 8.7.2 for notes on the /shmem_quiet/ routine.

------------------------------
XX.XX.5 Loud Barrier
------------------------------

Registers the arrival of a PE at a barrier and suspends PE execution until all
other PEs arrive at the barrier.  These operations are similar to
/shmem_barrier/ and /shmem_barrier_all/, with the distinction that they do not
wait for local and remote memory updates to complete.  Waiting for memory
updates to complete can be achieved by calling the /shmem_ctx_quiet/ operation
prior to calling the loud barrier routine.  The /shmem_barrier/ and
/shmem_barrier_all/ routines are equivalent to performing a /shmem_ctx_quiet/
operation on SHMEM_CTX_DEFAULT followed by the corresponding loud barrier
operation.

SYNOPSIS

    C/C++:
    void shmem_loud_barrier(int PE_start, int logPE_stride, int PE_size, long *pSync);
    void shmem_loud_barrier_all(void); 


    Fortran:
    WIP

DESCRIPTION

Arguments

API Description

    Same as barrier and barrier_all, with the exception of completing operations.

Return Values

    None.

Notes

    None.

------------------------------
XX.XX.6 Context Communication
------------------------------

The following additional routines are defined for performing communication on a
user-supplied communication context.  The existing versions of these routines
that do not take a context argument are defined as equivalent to the context
versions with the context argument of SHMEM_CTX_DEFAULT.

SYNOPSIS

    C/C++:
    void shmem_ctx_TYPE_put(TYPE *dest, const TYPE *source, size_t nelems, int pe);
    void shmem_ctx_put[,64,128,mem](void *dest, const void *source, size_t nelems, int pe);
    void shmem_ctx_TYPE_p(TYPE *addr, TYPE value, int pe);
    void shmem_ctx_TYPE_iput(TYPE *dest, const TYPE *source, ptrdiff_t dst, ptrdiff_t sst, size_t nelems, int pe);
    void shmem_ctx_iput[32,64,128](void *dest, const void *source, ptrdiff_t dst, ptrdiff_t sst, size_t nelems, int pe);

    void shmem_ctx_TYPE_get(TYPE *dest, const TYPE *source, size_t nelems, int pe);
    void shmem_ctx_get[,64,128,mem](void *dest, const void *source, size_t nelems, int pe);
    TYPE shmem_ctx_TYPE_g(TYPE *addr, int pe);
    void shmem_ctx_TYPE_iget(TYPE *dest, const TYPE *source, ptrdiff_t dst, ptrdiff_t sst, size_t nelems, int pe);
    void shmem_ctx_iget[32,64,128](void *dest, const void *source, ptrdiff_t dst, ptrdiff_t sst, size_t nelems, int pe);

    void shmem_TYPE_add(TYPE *dest, TYPE value, int pe);
    TYPE shmem_TYPE_cswap(TYPE *dest, TYPE cond, TYPE value, int pe);
    TYPE shmem_TYPE_swap(TYPE *dest, TYPE value, int pe);
    TYPE shmem_TYPE_finc(TYPE *dest, int pe);
    void shmem_TYPE_inc(TYPE *dest, int pe);
    TYPE shmem_TYPE_fadd(TYPE *dest, TYPE value, int pe);

    Fortran:
    WIP

DESCRIPTION

    These operations are identical to the corresponding functions that omit the
    context argument, with the difference that non-context routines are always
    performed on the SHMEM_CTX_DEFAULT context, whereas contex routines operate
    on any context, including SHMEM_CTX_DEFAULT.  Further, passing a /ctx/
    argument equal to SHMEM_CTX_NULL is invalid and results in undefined
    behavior.
    
    See non-context versions of these routines for this information.

Notes to OpenSHMEM committee

    In terms of organization of the document, we could add the context version
    of each communication operation alongside the non-context version, since
    they have the same behavior.

    For all of the functions listed, there will also be nonblocking versions
    that accept a context argument.

------------------------------
ADDITIONAL NOTES
------------------------------

shmem_barrier and shmem_barrier_all are defined to quiet only the default context
  - This is important because we want to avoid multiple threads using the same
    context concurrently and a barrier that touches all contexts could make
    it hard for us to eliminate the need for synchronization on per-context state.
